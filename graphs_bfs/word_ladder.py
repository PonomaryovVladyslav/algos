from collections import deque

def ladder_length(begin_word: str, end_word: str, word_list: list[str]) -> int:
    """
    –ù–∞—Ö–æ–¥–∏—Ç –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —à–∞–≥–æ–≤ –¥–ª—è –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏—è `begin_word` –≤ `end_word`
    —á–µ—Ä–µ–∑ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –æ–¥–Ω–æ–π –±—É–∫–≤—ã, –≥–¥–µ –∫–∞–∂–¥–æ–µ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω–æ–µ —Å–ª–æ–≤–æ
    –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –≤ `word_list`.

    üîπ **–ê–ª–≥–æ—Ä–∏—Ç–º (BFS, O(n * m^2))**:
    1Ô∏è‚É£ –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º `word_list` –≤ `set(word_set)` –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞.
    2Ô∏è‚É£ –ó–∞–ø—É—Å–∫–∞–µ–º BFS:
       - –í `queue` —Ö—Ä–∞–Ω–∏–º `(—Å–ª–æ–≤–æ, —à–∞–≥–∏)`, –Ω–∞—á–∏–Ω–∞—è —Å `begin_word`.
       - –ú–µ–Ω—è–µ–º **–∫–∞–∂–¥—É—é –±—É–∫–≤—É** –Ω–∞ **–≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –±—É–∫–≤—ã**.
       - –ï—Å–ª–∏ —Å–ª–æ–≤–æ –µ—Å—Ç—å –≤ `word_set`, –¥–æ–±–∞–≤–ª—è–µ–º –µ–≥–æ –≤ –æ—á–µ—Ä–µ–¥—å –∏ —É–¥–∞–ª—è–µ–º –∏–∑ –º–Ω–æ–∂–µ—Å—Ç–≤–∞.
    3Ô∏è‚É£ –ï—Å–ª–∏ –¥–æ—Å—Ç–∏–≥–ª–∏ `end_word`, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º `steps`, –∏–Ω–∞—á–µ `0`.

    üîπ **–í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å**:
       - `O(n * m^2)`, –≥–¥–µ `n` ‚Äî –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ª–æ–≤ –≤ `word_list`, `m` ‚Äî –¥–ª–∏–Ω–∞ —Å–ª–æ–≤–∞.

    üîπ **–ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å**:
       - `O(n)`, —Ç–∞–∫ –∫–∞–∫ —Ö—Ä–∞–Ω–∏–º `word_set` –∏ `queue`.

    :param begin_word: str - –ù–∞—á–∞–ª—å–Ω–æ–µ —Å–ª–æ–≤–æ.
    :param end_word: str - –¶–µ–ª–µ–≤–æ–µ —Å–ª–æ–≤–æ.
    :param word_list: list[str] - –°–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–ª–æ–≤.
    :return: int - –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —à–∞–≥–æ–≤ –∏–ª–∏ `0`, –µ—Å–ª–∏ –ø—É—Ç—å –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω.
    """
    word_set = set(word_list)  # –ü—Ä–µ–≤—Ä–∞—â–∞–µ–º –≤ set –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞
    if end_word not in word_set:
        return 0  # –ï—Å–ª–∏ —Ü–µ–ª–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞ –Ω–µ—Ç –≤ —Å–ª–æ–≤–∞—Ä–µ, –ø—É—Ç—å –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω

    queue = deque([(begin_word, 1)])  # (—Å–ª–æ–≤–æ, —à–∞–≥–∏)
    alphabet = "abcdefghijklmnopqrstuvwxyz"

    while queue:
        word, steps = queue.popleft()

        if word == end_word:
            return steps  # –î–æ—Å—Ç–∏–≥–ª–∏ —Ü–µ–ª–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞

        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ —Å–ª–æ–≤–∞, –º–µ–Ω—è—è –æ–¥–Ω—É –±—É–∫–≤—É
        for i in range(len(word)):
            for char in alphabet:
                if char != word[i]:  # –ú–µ–Ω—è–µ–º —Ç–æ–ª—å–∫–æ –Ω–∞ –¥—Ä—É–≥—É—é –±—É–∫–≤—É
                    new_word = word[:i] + char + word[i+1:]

                    if new_word in word_set:
                        queue.append((new_word, steps + 1))
                        word_set.remove(new_word)  # –£–¥–∞–ª—è–µ–º, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–π

    return 0  # –ï—Å–ª–∏ –ø—É—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω

# üîπ –¢–µ—Å—Ç—ã
print(ladder_length("hit", "cog", ["hot", "dot", "dog", "lot", "log", "cog"]))  # ‚úÖ 5
print(ladder_length("hit", "cog", ["hot", "dot", "dog", "lot", "log"]))  # ‚úÖ 0
