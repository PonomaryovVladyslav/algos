from collections import deque

def snakes_and_ladders(board: list[list[int]]) -> int:
    """
    –ù–∞—Ö–æ–¥–∏—Ç –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ö–æ–¥–æ–≤ –¥–ª—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –ø–æ—Å–ª–µ–¥–Ω–µ–π –∫–ª–µ—Ç–∫–∏ –≤ –∏–≥—Ä–µ "–ó–º–µ–∏ –∏ –ª–µ—Å—Ç–Ω–∏—Ü—ã".

    üîπ **–ê–ª–≥–æ—Ä–∏—Ç–º (BFS, O(n^2))**:
    1Ô∏è‚É£ –†–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ–º `board` –≤ 1D –º–∞—Å—Å–∏–≤ `cells`, —É—á–∏—Ç—ã–≤–∞—è –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∑–º–µ–π–∫–∏.
    2Ô∏è‚É£ –ó–∞–ø—É—Å–∫–∞–µ–º BFS:
       - –í `queue` —Ö—Ä–∞–Ω–∏–º `(–ø–æ–∑–∏—Ü–∏—è, —à–∞–≥–∏)`, –Ω–∞—á–∏–Ω–∞—è —Å `1`.
       - –ë—Ä–æ—Å–∞–µ–º –∫—É–±–∏–∫ (1-6) –∏ –ø–µ—Ä–µ—Ö–æ–¥–∏–º –Ω–∞ `next_pos`.
       - –ï—Å–ª–∏ –∫–ª–µ—Ç–∫–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç –∑–º–µ—é/–ª–µ—Å—Ç–Ω–∏—Ü—É, –ø–µ—Ä–µ–º–µ—â–∞–µ–º—Å—è.
       - –ï—Å–ª–∏ –¥–æ—Å—Ç–∏–≥–ª–∏ `n*n`, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º `—à–∞–≥–∏ + 1`.
    3Ô∏è‚É£ –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –ø—É—Ç—å, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º `-1`.

    üîπ **–í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å**:
       - `O(n^2)`, —Ç–∞–∫ –∫–∞–∫ BFS –ø—Ä–æ—Ö–æ–¥–∏—Ç –≤—Å–µ –∫–ª–µ—Ç–∫–∏ `n^2` –º–∞–∫—Å–∏–º—É–º –æ–¥–∏–Ω —Ä–∞–∑.

    üîπ **–ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å**:
       - `O(n^2)`, –∏–∑-–∑–∞ —Ö—Ä–∞–Ω–µ–Ω–∏—è `cells` –∏ `queue`.

    :param board: list[list[int]] - –ò–≥—Ä–æ–≤–∞—è –¥–æ—Å–∫–∞ `n x n`.
    :return: int - –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ö–æ–¥–æ–≤ –∏–ª–∏ `-1`, –µ—Å–ª–∏ –ø—É—Ç—å –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω.
    """
    n = len(board)

    # 1. –†–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ–º board –≤ 1D –º–∞—Å—Å–∏–≤ (Boustrophedon)
    cells = [-1] * (n * n + 1)
    idx = 1
    for r in range(n - 1, -1, -1):  # –î–≤–∏–≥–∞–µ–º—Å—è —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö
        row = range(n) if (n - 1 - r) % 2 == 0 else range(n - 1, -1, -1)
        for c in row:
            cells[idx] = board[r][c]
            idx += 1

    # 2. BFS (–ø–æ–∏—Å–∫ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –ø—É—Ç–∏)
    queue = deque([(1, 0)])  # (–ø–æ–∑–∏—Ü–∏—è, —à–∞–≥–∏)
    visited = set()

    while queue:
        pos, steps = queue.popleft()

        for dice in range(1, 7):  # –ë—Ä–æ—Å–∞–µ–º –∫—É–±–∏–∫ (1-6)
            next_pos = pos + dice
            if next_pos > n * n:
                continue  # –í—ã—Ö–æ–¥ –∑–∞ –ø—Ä–µ–¥–µ–ª—ã –¥–æ—Å–∫–∏

            if cells[next_pos] != -1:
                next_pos = cells[next_pos]  # –õ–µ—Å—Ç–Ω–∏—Ü–∞ –∏–ª–∏ –∑–º–µ—è

            if next_pos == n * n:
                return steps + 1  # –î–æ—Å—Ç–∏–≥–ª–∏ –∫–æ–Ω—Ü–∞

            if next_pos not in visited:
                visited.add(next_pos)
                queue.append((next_pos, steps + 1))

    return -1  # –ï—Å–ª–∏ –Ω–µ —Å–º–æ–≥–ª–∏ –¥–æ–±—Ä–∞—Ç—å—Å—è


# üîπ –¢–µ—Å—Ç
board1 = [
    [-1,-1,-1,-1,-1,-1],
    [-1,-1,-1,-1,-1,-1],
    [-1,-1,-1,-1,-1,-1],
    [-1,35,-1,-1,13,-1],
    [-1,-1,-1,-1,-1,-1],
    [-1,15,-1,-1,-1,-1]
]

print(snakes_and_ladders(board1))  # ‚úÖ 4
