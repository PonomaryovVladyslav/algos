# Задача: Дано целочисленный массив nums, где nums[i] обозначает максимальную длину прыжка с данной позиции.
# Нужно определить минимальное количество прыжков, необходимых для достижения последнего индекса массива.
# Гарантируется, что всегда можно добраться до последнего элемента.

def min_jumps(nums: list[int]) -> int:
    """
    Функция вычисляет минимальное количество прыжков, необходимых для достижения конца массива.

    :param nums: list[int] - массив, где nums[i] указывает, на сколько шагов можно прыгнуть с позиции i.
    :return: int - минимальное количество прыжков, необходимых для достижения конца массива.
    """

    n: int = len(nums)
    if n == 1:
        return 0  # Уже на последнем элементе, прыжки не нужны

    jumps: int = 0  # Количество прыжков
    max_reach: int = 0  # Самая дальняя достижимая позиция
    end: int = 0  # Граница текущего прыжка

    for i in range(n - 1):  # Не включаем последний элемент, так как не нужно прыгать с него
        max_reach = max(max_reach, i + nums[i])  # Обновляем максимальную достижимую позицию

        if i == end:  # Достигли конца текущего прыжка
            jumps += 1  # Совершаем прыжок
            end = max_reach  # Обновляем границу для следующего прыжка

            if end >= n - 1:  # Если можем достичь последнего элемента, выходим из цикла
                break

    return jumps


# Пример вызова функции
print(min_jumps([3, 2, 10, 1, 1, 1, 1, 1, 1, 1]))  # Ожидаемый результат: 2

"""
Анализ сложности:
- Временная сложность: O(n), так как мы проходим массив один раз.
- Пространственная сложность: O(1), так как используем только несколько дополнительных переменных.
"""
