# Задача: Автозаправочные станции
# Дано два списка: gas[i] — количество топлива на i-й станции,
# cost[i] — сколько топлива нужно, чтобы доехать до следующей станции.
# Нужно определить, с какой станции можно начать, чтобы объехать весь круг,
# или вернуть -1, если это невозможно.
# Гарантируется, что если решение существует, оно уникально.

def can_travel(gas: list[int], cost: list[int]) -> int:
    """
    Функция определяет, с какой заправочной станции можно начать,
    чтобы проехать весь круг.

    :param gas: list[int] - список количества топлива на каждой станции.
    :param cost: list[int] - список затрат топлива на переход к следующей станции.
    :return: int - индекс стартовой станции или -1, если объехать весь круг невозможно.
    """

    # Если суммарного топлива меньше, чем нужно для полного круга, решения нет
    if sum(gas) < sum(cost):
        return -1

    start: int = 0  # Стартовая станция
    tank: int = 0   # Текущее количество топлива в баке

    # Один проход по списку (O(n))
    for i in range(len(gas)):
        tank += gas[i] - cost[i]  # Обновляем уровень топлива в баке
        if tank < 0:  # Если на этой станции бак пуст – нельзя стартовать отсюда
            start = i + 1  # Сдвигаем стартовую станцию
            tank = 0  # Обнуляем топливо, так как начинаем новый маршрут

    return start  # Гарантировано, что решение уникально


# Примеры вызова функции
gas1  = [1, 2, 3, 4, 5]
cost1 = [3, 4, 5, 1, 2]
print(can_travel(gas1, cost1))  # Ожидаемый результат: 3

gas2  = [2, 3, 4]
cost2 = [3, 4, 3]
print(can_travel(gas2, cost2))  # Ожидаемый результат: -1

"""
Анализ сложности:
- Временная сложность: O(n), так как мы проходим массив только один раз.
- Пространственная сложность: O(1), так как используем только несколько переменных.
"""
