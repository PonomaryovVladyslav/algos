# Задача: Проверка возможности достичь последнего индекса массива.
# Дано: массив nums, где nums[i] обозначает максимальную длину прыжка с данной позиции.
# Нужно вернуть True, если можно достичь последнего индекса, иначе False.

# Примеры:
# Input: nums = [2,3,1,1,4]
# Output: True (можно прыгнуть 1 шаг до индекса 1, затем 3 шага до конца)
#
# Input: nums = [3,2,1,0,4]
# Output: False (всегда застрянем на индексе 3, так как nums[3] = 0)

def can_jump_v1(nums: list[int]) -> bool:
    """
    Проверяет, можно ли добраться до последнего индекса массива (итеративный метод).

    :param nums: list[int] - массив прыжков.
    :return: bool - True, если можно достичь конца, иначе False.
    """

    n: int = len(nums)
    if n == 1:
        return True  # Уже на последнем элементе

    max_reach: int = 0  # Самая дальняя достижимая позиция

    for i in range(n - 1):  # Не включаем последний элемент
        max_reach = max(max_reach, i + nums[i])  # Обновляем дальность прыжка
        if i == max_reach:  # Если дальность не увеличилась — застряли
            return False

    return True  # Если дошли до конца, возвращаем True


def can_jump_v2(nums: list[int]) -> bool:
    """
    Проверяет, можно ли добраться до последнего индекса массива (оптимизированный метод).

    :param nums: list[int] - массив прыжков.
    :return: bool - True, если можно достичь конца, иначе False.
    """

    max_reach: int = 0  # Самая дальняя достижимая позиция

    for i in range(len(nums)):
        if i > max_reach:  # Если индекс недостижим — возвращаем False
            return False
        max_reach = max(max_reach, i + nums[i])  # Обновляем дальность прыжка
        if max_reach >= len(nums) - 1:  # Если можем дойти до конца, сразу выходим
            return True

    return True  # Если прошли весь массив


# Примеры вызова функции
nums1 = [2, 3, 1, 1, 4]
nums2 = [3, 2, 1, 0, 4]

print(can_jump_v1(nums1))  # Ожидаемый результат: True
print(can_jump_v1(nums2))  # Ожидаемый результат: False
print(can_jump_v2(nums1))  # Ожидаемый результат: True
print(can_jump_v2(nums2))  # Ожидаемый результат: False

"""
Анализ сложности:
- Временная сложность: O(n), так как мы проходим массив один раз.
- Пространственная сложность: O(1), так как используем только несколько переменных.
"""
