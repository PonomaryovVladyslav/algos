from collections import deque


def num_islands(grid: list[list[str]]) -> int:
    """
    –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Å—Ç—Ä–æ–≤–æ–≤ –≤ `grid` —Å –ø–æ–º–æ—â—å—é DFS.

    üîπ **–ê–ª–≥–æ—Ä–∏—Ç–º (DFS, O(m * n))**:
    1Ô∏è‚É£ –û–±—Ö–æ–¥ —Å–µ—Ç–∫–∏, –∏—â–µ–º `1` (–Ω–æ–≤—ã–π –æ—Å—Ç—Ä–æ–≤).
    2Ô∏è‚É£ –ó–∞–ø—É—Å–∫–∞–µ–º DFS –æ—Ç –Ω–∞–π–¥–µ–Ω–Ω–æ–π –∫–ª–µ—Ç–∫–∏, –ø–æ–º–µ—á–∞—è –≤–µ—Å—å –æ—Å—Ç—Ä–æ–≤ `0`.
    3Ô∏è‚É£ –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á—ë—Ç—á–∏–∫ –æ—Å—Ç—Ä–æ–≤–æ–≤ (`count`).

    üîπ **–í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å**:
       - `O(m * n)`, —Ç–∞–∫ –∫–∞–∫ –∫–∞–∂–¥—É—é –∫–ª–µ—Ç–∫—É –ø–æ—Å–µ—â–∞–µ–º –æ–¥–∏–Ω —Ä–∞–∑.

    üîπ **–ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å**:
       - `O(m * n)` –≤ —Ö—É–¥—à–µ–º —Å–ª—É—á–∞–µ (–≤–µ—Å—å grid ‚Äî –æ–¥–∏–Ω –æ—Å—Ç—Ä–æ–≤).

    :param grid: list[list[str]] - –î–≤–æ–∏—á–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞ (`1` - —Å—É—à–∞, `0` - –≤–æ–¥–∞).
    :return: int - –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Å—Ç—Ä–æ–≤–æ–≤.
    """
    if not grid:
        return 0

    rows, cols = len(grid), len(grid[0])
    count = 0

    def dfs(r, c):
        if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == '0':
            return
        grid[r][c] = '0'  # –ü–æ–º–µ—á–∞–µ–º –∫–ª–µ—Ç–∫—É –∫–∞–∫ –ø–æ—Å–µ—â—ë–Ω–Ω—É—é
        dfs(r + 1, c)  # –í–Ω–∏–∑
        dfs(r - 1, c)  # –í–≤–µ—Ä—Ö
        dfs(r, c + 1)  # –í–ø—Ä–∞–≤–æ
        dfs(r, c - 1)  # –í–ª–µ–≤–æ

    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '1':  # –ù–∞—à–ª–∏ –Ω–æ–≤—ã–π –æ—Å—Ç—Ä–æ–≤
                count += 1
                dfs(r, c)  # –ü–æ–º–µ—á–∞–µ–º –≤–µ—Å—å –æ—Å—Ç—Ä–æ–≤

    return count


# üîπ –¢–µ—Å—Ç
grid = [
    ["1", "1", "0", "0", "0"],
    ["1", "1", "0", "0", "0"],
    ["0", "0", "1", "0", "0"],
    ["0", "0", "0", "1", "1"]
]

print(num_islands(grid))  # ‚úÖ 3


def num_islands_bfs(grid: list[list[str]]) -> int:
    """
    –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Å—Ç—Ä–æ–≤–æ–≤ –≤ `grid` —Å –ø–æ–º–æ—â—å—é BFS.

    üîπ **–ê–ª–≥–æ—Ä–∏—Ç–º (BFS, O(m * n))**:
    1Ô∏è‚É£ –û–±—Ö–æ–¥ —Å–µ—Ç–∫–∏, –∏—â–µ–º `1` (–Ω–æ–≤—ã–π –æ—Å—Ç—Ä–æ–≤).
    2Ô∏è‚É£ –ó–∞–ø—É—Å–∫–∞–µ–º BFS –æ—Ç –Ω–∞–π–¥–µ–Ω–Ω–æ–π –∫–ª–µ—Ç–∫–∏, –ø–æ–º–µ—á–∞—è –≤–µ—Å—å –æ—Å—Ç—Ä–æ–≤ `0`.
    3Ô∏è‚É£ –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á—ë—Ç—á–∏–∫ –æ—Å—Ç—Ä–æ–≤–æ–≤ (`count`).

    üîπ **–í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å**:
       - `O(m * n)`, —Ç–∞–∫ –∫–∞–∫ –∫–∞–∂–¥—É—é –∫–ª–µ—Ç–∫—É –ø–æ—Å–µ—â–∞–µ–º –æ–¥–∏–Ω —Ä–∞–∑.

    üîπ **–ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å**:
       - `O(min(m, n))` (–≥–ª—É–±–∏–Ω–∞ –æ—á–µ—Ä–µ–¥–∏ BFS).

    :param grid: list[list[str]] - –î–≤–æ–∏—á–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞ (`1` - —Å—É—à–∞, `0` - –≤–æ–¥–∞).
    :return: int - –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Å—Ç—Ä–æ–≤–æ–≤.
    """
    if not grid:
        return 0

    rows, cols = len(grid), len(grid[0])
    count = 0
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # –í–Ω–∏–∑, –≤–≤–µ—Ä—Ö, –≤–ø—Ä–∞–≤–æ, –≤–ª–µ–≤–æ

    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '1':  # –ù–æ–≤—ã–π –æ—Å—Ç—Ä–æ–≤
                count += 1
                queue = deque([(r, c)])
                grid[r][c] = '0'  # –ü–æ–º–µ—á–∞–µ–º –∫–∞–∫ –ø–æ—Å–µ—â—ë–Ω–Ω–æ–µ

                while queue:
                    x, y = queue.popleft()
                    for dx, dy in directions:
                        nx, ny = x + dx, y + dy
                        if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == '1':
                            queue.append((nx, ny))
                            grid[nx][ny] = '0'  # –ü–æ–º–µ—á–∞–µ–º –∫–∞–∫ –ø–æ—Å–µ—â—ë–Ω–Ω–æ–µ

    return count


# üîπ –¢–µ—Å—Ç
print(num_islands_bfs([
    ["1", "1", "0", "0", "0"],
    ["1", "1", "0", "0", "0"],
    ["0", "0", "1", "0", "0"],
    ["0", "0", "0", "1", "1"]
]))  # ‚úÖ 3
